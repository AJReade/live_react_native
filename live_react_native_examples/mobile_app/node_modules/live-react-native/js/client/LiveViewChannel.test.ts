// Tests for LiveViewChannel - Phoenix Channel wrapper for React Native LiveView integration
import { LiveViewChannel } from './LiveViewChannel';
import { Socket } from 'phoenix';

// **NEW TESTS FOR FUNCTIONAL API (Phase 1.3 Refactoring)**
describe('createLiveViewClient() Functional API', () => {
  let createLiveViewClient: any;
  let mockSocket: any;
  let mockChannel: any;

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock Phoenix Channel methods with chainable receive
    const mockJoinPush = {
      receive: jest.fn().mockReturnThis(),
    };
    const mockLeavePush = {
      receive: jest.fn().mockReturnThis(),
    };
    const mockEventPush = {
      receive: jest.fn().mockReturnThis(),
    };

    mockChannel = {
      join: jest.fn().mockReturnValue(mockJoinPush),
      leave: jest.fn().mockReturnValue(mockLeavePush),
      push: jest.fn().mockReturnValue(mockEventPush),
      on: jest.fn().mockReturnValue(123), // Return a reference number
      off: jest.fn(),
      onClose: jest.fn(),
      onError: jest.fn(),
    };

    mockSocket = {
      connect: jest.fn(),
      disconnect: jest.fn(),
      channel: jest.fn().mockReturnValue(mockChannel),
      onOpen: jest.fn(),
      onClose: jest.fn(),
      onError: jest.fn(),
      isConnected: jest.fn().mockReturnValue(false),
    };

    (Socket as jest.Mock).mockReturnValue(mockSocket);

    // Import the function we're going to create
    try {
      createLiveViewClient = require('./LiveViewChannel').createLiveViewClient;
    } catch {
      // Function doesn't exist yet - this test should fail initially
      createLiveViewClient = () => { throw new Error('createLiveViewClient not implemented'); };
    }
  });

  describe('Factory Function', () => {
    test('createLiveViewClient creates a client instance', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket',
        params: { _csrf_token: 'test-token' }
      });

      expect(client).toBeDefined();
      expect(typeof client.connect).toBe('function');
      expect(typeof client.disconnect).toBe('function');
      expect(typeof client.joinLiveView).toBe('function');
      expect(typeof client.leaveLiveView).toBe('function');
      expect(typeof client.pushEvent).toBe('function');
      expect(typeof client.pushEventTo).toBe('function');
      expect(typeof client.handleEvent).toBe('function');
    });

    test('createLiveViewClient accepts configuration options', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket',
        params: { _csrf_token: 'test-token' },
        reconnectDelay: (attempt) => attempt * 1000,
        debug: true
      });

      expect(client).toBeDefined();
    });
  });

  describe('Connection Management', () => {
    test('client.connect() returns a Promise', async () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      // Should return a Promise
      const connectPromise = client.connect();
      expect(connectPromise).toBeInstanceOf(Promise);

      // Simulate successful connection
      const onOpenCallback = mockSocket.onOpen.mock.calls[0][0];
      onOpenCallback();

      await expect(connectPromise).resolves.toBeUndefined();
      expect(mockSocket.connect).toHaveBeenCalled();
    });

    test('client.disconnect() immediately disconnects', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      client.disconnect();

      expect(mockSocket.disconnect).toHaveBeenCalled();
    });
  });

  describe('LiveView Management', () => {
    test('client.joinLiveView(path, params, onAssignsUpdate) joins with simplified signature', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      const onAssignsUpdate = jest.fn();
      client.joinLiveView('/counter', { initial_count: 0 }, onAssignsUpdate);

      expect(mockSocket.channel).toHaveBeenCalledWith('/counter', { initial_count: 0 });
      expect(mockChannel.join).toHaveBeenCalled();

      // Should set up assigns update callback
      expect(mockChannel.on).toHaveBeenCalledWith('assigns_update', expect.any(Function));
    });

    test('client.leaveLiveView() leaves current LiveView', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      // First join
      client.joinLiveView('/counter', {}, jest.fn());

      // Then leave
      client.leaveLiveView();

      expect(mockChannel.leave).toHaveBeenCalled();
    });
  });

  describe('Event System', () => {
    test('client.pushEvent(event, payload) sends event without callback', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      client.joinLiveView('/counter', {}, jest.fn());
      client.pushEvent('increment', { amount: 1 });

      expect(mockChannel.push).toHaveBeenCalledWith('increment', { amount: 1 });
    });

    test('client.pushEvent(event, payload, onReply) sends event with callback', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      const onReply = jest.fn();
      client.joinLiveView('/counter', {}, jest.fn());
      const ref = client.pushEvent('validate', { data: 'test' }, onReply);

      expect(mockChannel.push).toHaveBeenCalledWith('validate', { data: 'test' });
      expect(typeof ref).toBe('number'); // Should return a reference number
    });

    test('client.pushEventTo(target, event, payload) sends targeted event', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      client.joinLiveView('/form', {}, jest.fn());
      client.pushEventTo('#user-form', 'submit', { name: 'John' });

      expect(mockChannel.push).toHaveBeenCalledWith('submit', {
        name: 'John',
        phx_target: '#user-form'
      });
    });

    test('client.handleEvent(event, callback) returns unsubscribe function', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      // First join a LiveView to make channel available
      client.joinLiveView('/test', {}, jest.fn());

      const callback = jest.fn();
      const unsubscribe = client.handleEvent('user_updated', callback);

      expect(typeof unsubscribe).toBe('function');
      expect(mockChannel.on).toHaveBeenCalledWith('user_updated', callback);

      // Test unsubscribe - should call off with event name and reference number
      unsubscribe();
      expect(mockChannel.off).toHaveBeenCalledWith('user_updated', expect.any(Number));
    });

    test('client.handleEvent handles RN commands automatically', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      client.joinLiveView('/counter', {}, jest.fn());

      // Should automatically handle rn:haptic events
      expect(mockChannel.on).toHaveBeenCalledWith('rn:haptic', expect.any(Function));
      expect(mockChannel.on).toHaveBeenCalledWith('rn:navigate', expect.any(Function));
      expect(mockChannel.on).toHaveBeenCalledWith('rn:vibrate', expect.any(Function));
    });
  });

  describe('Error Handling', () => {
    test('client.pushEvent throws error when not joined', () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket'
      });

      expect(() => {
        client.pushEvent('increment', {});
      }).toThrow('Cannot push event: not joined to a LiveView');
    });

    test('client.connect handles connection errors', async () => {
      const client = createLiveViewClient({
        url: 'ws://localhost:4000/live/websocket',
        onError: jest.fn(),
        onReconnect: jest.fn()
      });

      const connectPromise = client.connect();

      // Simulate connection error
      const onErrorCallback = mockSocket.onError.mock.calls[0][0];
      onErrorCallback(new Error('Connection failed'));

      await expect(connectPromise).rejects.toThrow('Connection failed');
    });
  });
});

// **EXISTING TESTS (Legacy LiveViewChannel class)**
// Mock Phoenix Socket and Channel
jest.mock('phoenix', () => ({
  Socket: jest.fn().mockImplementation(() => ({
    connect: jest.fn(),
    disconnect: jest.fn(),
    channel: jest.fn().mockReturnValue({
      join: jest.fn().mockReturnValue({
        receive: jest.fn().mockReturnThis(),
      }),
      leave: jest.fn().mockReturnValue({
        receive: jest.fn().mockReturnThis(),
      }),
      push: jest.fn().mockReturnValue({
        receive: jest.fn().mockReturnThis(),
      }),
      on: jest.fn(),
      off: jest.fn(),
      onClose: jest.fn(),
      onError: jest.fn(),
    }),
    onOpen: jest.fn(),
    onClose: jest.fn(),
    onError: jest.fn(),
    isConnected: jest.fn().mockReturnValue(false),
  })),
}));

describe('LiveViewChannel', () => {
  let liveViewChannel: LiveViewChannel;
  let mockSocket: any;
  let mockChannel: any;

    beforeEach(() => {
    jest.clearAllMocks();

    // Create shared mock push objects that can be reused
    const mockJoinPush = {
      receive: jest.fn().mockReturnThis(),
    };
    const mockLeavePush = {
      receive: jest.fn().mockReturnThis(),
    };
    const mockEventPush = {
      receive: jest.fn().mockReturnThis(),
    };

    mockChannel = {
      join: jest.fn().mockReturnValue(mockJoinPush),
      leave: jest.fn().mockReturnValue(mockLeavePush),
      push: jest.fn().mockReturnValue(mockEventPush),
      on: jest.fn(),
      off: jest.fn(),
      onClose: jest.fn(),
      onError: jest.fn(),
    };

    mockSocket = {
      connect: jest.fn(),
      disconnect: jest.fn(),
      channel: jest.fn().mockReturnValue(mockChannel),
      onOpen: jest.fn(),
      onClose: jest.fn(),
      onError: jest.fn(),
      isConnected: jest.fn().mockReturnValue(false),
    };

    (Socket as jest.Mock).mockReturnValue(mockSocket);
  });

  describe('constructor', () => {
    test('creates Socket with correct endpoint and options', () => {
      const options = {
        url: 'ws://localhost:4000/socket',
        params: { token: 'auth-token' },
        reconnectOnError: true,
      };

      liveViewChannel = new LiveViewChannel(options);

      expect(Socket).toHaveBeenCalledWith('ws://localhost:4000/socket', {
        params: { token: 'auth-token' },
        reconnectAfterMs: expect.any(Function),
      });
    });

    test('uses default reconnection strategy', () => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });

      const [[, socketOptions]] = (Socket as jest.Mock).mock.calls;
      const reconnectFn = socketOptions.reconnectAfterMs;

      // Test exponential backoff: [1000, 2000, 5000, 10000, 30000]
      expect(reconnectFn(1)).toBe(1000);
      expect(reconnectFn(2)).toBe(2000);
      expect(reconnectFn(3)).toBe(5000);
      expect(reconnectFn(6)).toBe(30000); // caps at 30s
    });

    test('allows custom reconnection strategy', () => {
      const customReconnect = (tries: number) => tries * 500;

      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
        reconnectDelay: customReconnect,
      });

      const [[, socketOptions]] = (Socket as jest.Mock).mock.calls;
      expect(socketOptions.reconnectAfterMs).toBe(customReconnect);
    });
  });

  describe('connect()', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
    });

    test('calls socket.connect() and sets up lifecycle hooks', () => {
      liveViewChannel.connect();

      expect(mockSocket.connect).toHaveBeenCalled();
      expect(mockSocket.onOpen).toHaveBeenCalled();
      expect(mockSocket.onClose).toHaveBeenCalled();
      expect(mockSocket.onError).toHaveBeenCalled();
    });

    test('updates connection state on open', () => {
      liveViewChannel.connect();

      const onOpenCallback = mockSocket.onOpen.mock.calls[0][0];
      onOpenCallback();

      expect(liveViewChannel.isConnected()).toBe(true);
    });

    test('updates connection state on close', () => {
      liveViewChannel.connect();

      const onCloseCallback = mockSocket.onClose.mock.calls[0][0];
      onCloseCallback();

      expect(liveViewChannel.isConnected()).toBe(false);
    });

    test('triggers onConnectionChange callback', () => {
      const connectionCallback = jest.fn();
      liveViewChannel.onConnectionChange(connectionCallback);
      liveViewChannel.connect();

      const onOpenCallback = mockSocket.onOpen.mock.calls[0][0];
      onOpenCallback();

      expect(connectionCallback).toHaveBeenCalledWith(true);
    });
  });

  describe('disconnect()', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
    });

    test('calls socket.disconnect()', () => {
      liveViewChannel.disconnect();

      expect(mockSocket.disconnect).toHaveBeenCalled();
    });

    test('leaves channel if connected', () => {
      liveViewChannel.connect();
      liveViewChannel.joinLiveView('lv:counter', {});

      liveViewChannel.disconnect();

      expect(mockChannel.leave).toHaveBeenCalled();
    });
  });

  describe('joinLiveView()', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
    });

    test('creates channel with topic and params', () => {
      const topic = 'lv:counter';
      const params = { user_id: 123 };

      liveViewChannel.joinLiveView(topic, params);

      expect(mockSocket.channel).toHaveBeenCalledWith(topic, params);
    });

    test('joins channel and sets up event handlers', () => {
      liveViewChannel.joinLiveView('lv:counter', {});

      expect(mockChannel.join).toHaveBeenCalled();
      expect(mockChannel.onClose).toHaveBeenCalled();
      expect(mockChannel.onError).toHaveBeenCalled();
    });

        test('handles successful join with callback', () => {
      const onJoin = jest.fn();

      liveViewChannel.joinLiveView('lv:counter', {}, { onJoin });

      // Get the mock push object that was returned by join()
      const joinPush = mockChannel.join.mock.results[0].value;
      const receiveCallback = joinPush.receive.mock.calls.find(
        ([status]) => status === 'ok'
      )[1];

      const joinResponse = { assigns: { count: 0 } };
      receiveCallback(joinResponse);

      expect(onJoin).toHaveBeenCalledWith(joinResponse);
    });

    test('handles join error with callback', () => {
      const onError = jest.fn();

      liveViewChannel.joinLiveView('lv:counter', {}, { onError });

      const joinPush = mockChannel.join.mock.results[0].value;
      const errorCallback = joinPush.receive.mock.calls.find(
        ([status]) => status === 'error'
      )[1];

      const error = { reason: 'unauthorized' };
      errorCallback(error);

      expect(onError).toHaveBeenCalledWith(error);
    });

    test('handles join timeout with callback', () => {
      const onError = jest.fn();

      liveViewChannel.joinLiveView('lv:counter', {}, { onError });

      const joinPush = mockChannel.join.mock.results[0].value;
      const timeoutCallback = joinPush.receive.mock.calls.find(
        ([status]) => status === 'timeout'
      )[1];

      timeoutCallback();

      expect(onError).toHaveBeenCalledWith({ reason: 'timeout' });
    });
  });

  describe('leaveLiveView()', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
      liveViewChannel.joinLiveView('lv:counter', {});
    });

    test('leaves current channel', () => {
      liveViewChannel.leaveLiveView();

      expect(mockChannel.leave).toHaveBeenCalled();
    });

    test('handles successful leave with callback', () => {
      const onLeave = jest.fn();

      liveViewChannel.leaveLiveView({ onLeave });

      const leavePush = mockChannel.leave.mock.results[0].value;
      const receiveCallback = leavePush.receive.mock.calls.find(
        ([status]) => status === 'ok'
      )[1];

      receiveCallback();

      expect(onLeave).toHaveBeenCalled();
    });
  });

  describe('pushEvent()', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
      liveViewChannel.joinLiveView('lv:counter', {});
    });

    test('pushes event to channel with payload', () => {
      const event = 'increment';
      const payload = { amount: 5 };

      liveViewChannel.pushEvent(event, payload);

      expect(mockChannel.push).toHaveBeenCalledWith(event, payload);
    });

    test('handles successful event response', () => {
      const onSuccess = jest.fn();

      liveViewChannel.pushEvent('increment', {}, { onSuccess });

      const pushReturn = mockChannel.push.mock.results[0].value;
      const successCallback = pushReturn.receive.mock.calls.find(
        ([status]) => status === 'ok'
      )[1];

      const response = { status: 'ok' };
      successCallback(response);

      expect(onSuccess).toHaveBeenCalledWith(response);
    });

    test('handles event error response', () => {
      const onError = jest.fn();

      liveViewChannel.pushEvent('increment', {}, { onError });

      const pushReturn = mockChannel.push.mock.results[0].value;
      const errorCallback = pushReturn.receive.mock.calls.find(
        ([status]) => status === 'error'
      )[1];

      const error = { reason: 'invalid_input' };
      errorCallback(error);

      expect(onError).toHaveBeenCalledWith(error);
    });

    test('throws error if no channel joined', () => {
      const newChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });

      expect(() => {
        newChannel.pushEvent('increment', {});
      }).toThrow('Cannot push event: no LiveView channel joined');
    });
  });

    describe('onAssignsUpdate()', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
      liveViewChannel.joinLiveView('lv:counter', {});
    });

    test('subscribes to assigns_update events', () => {
      const callback = jest.fn();

      liveViewChannel.onAssignsUpdate(callback);

      expect(mockChannel.on).toHaveBeenCalledWith('assigns_update', callback);
    });

    test('processes LiveView assigns updates', () => {
      const callback = jest.fn();
      liveViewChannel.onAssignsUpdate(callback);

      // Simulate receiving update from LiveReactNative.serialize_assigns/1
      const updateCallback = mockChannel.on.mock.calls.find(
        ([event]) => event === 'assigns_update'
      )[1];

      const assignsUpdate = {
        assigns: { count: 5, user: { name: 'John' } },
        changed: true,
      };

      updateCallback(assignsUpdate);

      expect(callback).toHaveBeenCalledWith(assignsUpdate);
    });
  });

  describe('reconnection handling', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
        reconnectOnError: true,
        maxReconnectAttempts: 3,
      });
    });

    test('tracks reconnection attempts', () => {
      liveViewChannel.connect();

      // Simulate connection error
      const onErrorCallback = mockSocket.onError.mock.calls[0][0];

      onErrorCallback(new Error('Connection lost'));
      onErrorCallback(new Error('Connection lost'));
      onErrorCallback(new Error('Connection lost'));

      expect(liveViewChannel.getReconnectAttempts()).toBe(3);
    });

    test('stops reconnecting after max attempts', () => {
      const onMaxReconnectAttempts = jest.fn();
      liveViewChannel.onMaxReconnectAttempts(onMaxReconnectAttempts);

      liveViewChannel.connect();

      const onErrorCallback = mockSocket.onError.mock.calls[0][0];

      // Exceed max attempts
      for (let i = 0; i < 4; i++) {
        onErrorCallback(new Error('Connection lost'));
      }

      expect(onMaxReconnectAttempts).toHaveBeenCalled();
    });

    test('resets reconnection attempts on successful connection', () => {
      liveViewChannel.connect();

      // Simulate error then recovery
      const onErrorCallback = mockSocket.onError.mock.calls[0][0];
      const onOpenCallback = mockSocket.onOpen.mock.calls[0][0];

      onErrorCallback(new Error('Connection lost'));
      expect(liveViewChannel.getReconnectAttempts()).toBe(1);

      onOpenCallback();
      expect(liveViewChannel.getReconnectAttempts()).toBe(0);
    });
  });

  describe('error handling', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
    });

    test('handles socket errors with callback', () => {
      const onError = jest.fn();
      liveViewChannel.onError(onError);

      liveViewChannel.connect();

      const errorCallback = mockSocket.onError.mock.calls[0][0];
      const error = new Error('Network error');
      errorCallback(error);

      expect(onError).toHaveBeenCalledWith(error);
    });

    test('handles channel errors with callback', () => {
      const onError = jest.fn();
      liveViewChannel.onError(onError);

      liveViewChannel.joinLiveView('lv:counter', {});

      const channelErrorCallback = mockChannel.onError.mock.calls[0][0];
      const error = new Error('Channel crashed');
      channelErrorCallback(error);

      expect(onError).toHaveBeenCalledWith(error);
    });
  });

  describe('state management', () => {
    beforeEach(() => {
      liveViewChannel = new LiveViewChannel({
        url: 'ws://localhost:4000/socket',
        path: 'lv:page',
      });
    });

        test('returns correct connection state', () => {
      expect(liveViewChannel.isConnected()).toBe(false);

      // Simulate connection by triggering the onOpen callback
      liveViewChannel.connect();
      const onOpenCallback = mockSocket.onOpen.mock.calls[0][0];
      onOpenCallback();

      expect(liveViewChannel.isConnected()).toBe(true);
    });

    test('returns current channel topic', () => {
      expect(liveViewChannel.getCurrentTopic()).toBeNull();

      liveViewChannel.joinLiveView('lv:counter', {});
      expect(liveViewChannel.getCurrentTopic()).toBe('lv:counter');
    });

    test('tracks connection state internally', () => {
      expect(liveViewChannel.getConnectionState()).toEqual({
        connected: false,
        connecting: false,
        error: null,
        reconnectAttempt: 0,
      });
    });
  });
});