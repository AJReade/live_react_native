// TODO: Implement in Phase 1.3
import { Socket, Channel } from 'phoenix';
import {
  LiveViewOptions,
  LiveViewJoinOptions,
  LiveViewLeaveOptions,
  PushEventOptions,
  ConnectionState,
  LiveViewAssignsUpdate,
} from '../types';

export class LiveViewChannel {
  private socket: Socket;
  private channel: Channel | null = null;
  private currentTopic: string | null = null;
  private connectionState: ConnectionState;
  private connectionCallbacks: ((connected: boolean) => void)[] = [];
  private errorCallbacks: ((error: Error) => void)[] = [];
  private maxReconnectAttemptsCallback: (() => void) | null = null;
  private maxReconnectAttempts: number;

  constructor(options: LiveViewOptions) {
    this.maxReconnectAttempts = options.maxReconnectAttempts || 5;

    this.connectionState = {
      connected: false,
      connecting: false,
      error: null,
      reconnectAttempt: 0,
    };

    const socketOptions: any = {};

    if (options.params) {
      socketOptions.params = options.params;
    }

    if (options.reconnectDelay) {
      socketOptions.reconnectAfterMs = options.reconnectDelay;
    } else {
      // Default exponential backoff: [1000, 2000, 5000, 10000, 30000]
      socketOptions.reconnectAfterMs = (tries: number) => {
        const delays = [1000, 2000, 5000, 10000, 30000];
        return delays[tries - 1] || 30000; // cap at 30s
      };
    }

    this.socket = new Socket(options.url, socketOptions);
  }

  connect(): void {
    this.connectionState.connecting = true;

    this.socket.onOpen(() => {
      this.connectionState.connected = true;
      this.connectionState.connecting = false;
      this.connectionState.error = null;
      this.connectionState.reconnectAttempt = 0; // Reset on successful connection

      this.connectionCallbacks.forEach(callback => callback(true));
    });

    this.socket.onClose(() => {
      this.connectionState.connected = false;
      this.connectionState.connecting = false;

      this.connectionCallbacks.forEach(callback => callback(false));
    });

    this.socket.onError((error: Error) => {
      this.connectionState.error = error;
      this.connectionState.connecting = false;
      this.connectionState.reconnectAttempt += 1;

      this.errorCallbacks.forEach(callback => callback(error));

      // Check if we've exceeded max reconnect attempts
      if (this.connectionState.reconnectAttempt >= this.maxReconnectAttempts) {
        if (this.maxReconnectAttemptsCallback) {
          this.maxReconnectAttemptsCallback();
        }
      }
    });

    this.socket.connect();
  }

  disconnect(): void {
    if (this.channel) {
      this.channel.leave();
      this.channel = null;
      this.currentTopic = null;
    }

    this.socket.disconnect();
    this.connectionState.connected = false;
    this.connectionState.connecting = false;
  }

  joinLiveView(topic: string, params: Record<string, any> = {}, options: LiveViewJoinOptions = {}): void {
    this.channel = this.socket.channel(topic, params);
    this.currentTopic = topic;

    this.channel.join()
      .receive('ok', (response: any) => {
        if (options.onJoin) {
          options.onJoin(response);
        }
      })
      .receive('error', (error: any) => {
        if (options.onError) {
          options.onError(error);
        }
      })
      .receive('timeout', () => {
        if (options.onError) {
          options.onError({ reason: 'timeout' });
        }
      });

    this.channel.onClose(() => {
      this.currentTopic = null;
    });

    this.channel.onError((error: Error) => {
      this.errorCallbacks.forEach(callback => callback(error));
    });
  }

  leaveLiveView(options: LiveViewLeaveOptions = {}): void {
    if (!this.channel) {
      return;
    }

    this.channel.leave()
      .receive('ok', () => {
        if (options.onLeave) {
          options.onLeave();
        }
      });

    this.channel = null;
    this.currentTopic = null;
  }

  pushEvent(event: string, payload: Record<string, any> = {}, options: PushEventOptions = {}): void {
    if (!this.channel) {
      throw new Error('Cannot push event: no LiveView channel joined');
    }

    this.channel.push(event, payload)
      .receive('ok', (response: any) => {
        if (options.onSuccess) {
          options.onSuccess(response);
        }
      })
      .receive('error', (error: any) => {
        if (options.onError) {
          options.onError(error);
        }
      });
  }

  onAssignsUpdate(callback: (update: LiveViewAssignsUpdate) => void): void {
    if (!this.channel) {
      return;
    }

    this.channel.on('assigns_update', callback);
  }

  // Event handler registration
  onConnectionChange(callback: (connected: boolean) => void): void {
    this.connectionCallbacks.push(callback);
  }

  onError(callback: (error: Error) => void): void {
    this.errorCallbacks.push(callback);
  }

  onMaxReconnectAttempts(callback: () => void): void {
    this.maxReconnectAttemptsCallback = callback;
  }

  // State getters
  isConnected(): boolean {
    return this.connectionState.connected;
  }

  getCurrentTopic(): string | null {
    return this.currentTopic;
  }

  getReconnectAttempts(): number {
    return this.connectionState.reconnectAttempt;
  }

  getConnectionState(): ConnectionState {
    return { ...this.connectionState };
  }

  // Channel getter for functional API
  getChannel(): Channel | null {
    return this.channel;
  }
}

// **NEW FUNCTIONAL API (Phase 1.3)**

// Configuration interface for the factory function
export interface LiveViewClientOptions {
  url: string;
  params?: Record<string, any>;
  reconnectDelay?: (attempt: number) => number;
  debug?: boolean;
  onError?: (error: Error) => void;
  onReconnect?: () => void;
}

// Client instance interface
export interface LiveViewClient {
  connect(): Promise<void>;
  disconnect(): void;
  joinLiveView(path: string, params: Record<string, any>, onAssignsUpdate: (assigns: Record<string, any>) => void): void;
  leaveLiveView(): void;
  pushEvent(event: string, payload?: Record<string, any>, onReply?: (reply: any, ref: number) => void): number;
  pushEventTo(target: string, event: string, payload?: Record<string, any>, onReply?: (reply: any, ref: number) => void): number;
  handleEvent(event: string, callback: (payload: any) => void): () => void;
}

// Factory function that creates a LiveView client instance
export function createLiveViewClient(options: LiveViewClientOptions): LiveViewClient {
  const channel = new LiveViewChannel({
    url: options.url,
    params: options.params,
    reconnectDelay: options.reconnectDelay,
  });

  let eventRef = 0;
  const eventHandlers = new Map<string, Set<(data: any) => void>>();

  // Built-in RN command handlers
  const setupRNCommandHandlers = () => {
    // Auto-handle React Native specific commands
    channel.getChannel()?.on('rn:haptic', (payload: any) => {
      if (options.debug) {
        console.log('RN Command: haptic', payload);
      }
      // TODO: Implement actual haptic feedback in React Native
    });

    channel.getChannel()?.on('rn:navigate', (payload: any) => {
      if (options.debug) {
        console.log('RN Command: navigate', payload);
      }
      // TODO: Implement actual navigation in React Native
    });

    channel.getChannel()?.on('rn:vibrate', (payload: any) => {
      if (options.debug) {
        console.log('RN Command: vibrate', payload);
      }
      // TODO: Implement actual vibration in React Native
    });
  };

  const client: LiveViewClient = {
    connect(): Promise<void> {
      return new Promise((resolve, reject) => {
        let resolved = false;

        channel.onConnectionChange((connected) => {
          if (connected && !resolved) {
            resolved = true;
            if (options.onReconnect) {
              options.onReconnect();
            }
            resolve();
          }
        });

        channel.onError((error) => {
          if (!resolved) {
            resolved = true;
            if (options.onError) {
              options.onError(error);
            }
            reject(error);
          }
        });

        channel.connect();
      });
    },

    disconnect(): void {
      channel.disconnect();
    },

    joinLiveView(path: string, params: Record<string, any>, onAssignsUpdate: (assigns: Record<string, any>) => void): void {
      channel.joinLiveView(path, params, {
        onJoin: (response: any) => {
          if (response.assigns) {
            onAssignsUpdate(response.assigns);
          }
        },
        onError: (error: any) => {
          if (options.onError) {
            options.onError(new Error(`Failed to join LiveView: ${JSON.stringify(error)}`));
          }
        }
      });

      // Set up assigns update listener - use the channel directly for test compatibility
      channel.getChannel()?.on('assigns_update', (update: LiveViewAssignsUpdate) => {
        onAssignsUpdate(update.assigns);
      });

      // Set up RN command handlers
      setupRNCommandHandlers();
    },

    leaveLiveView(): void {
      channel.leaveLiveView();
    },

    pushEvent(event: string, payload: Record<string, any> = {}, onReply?: (reply: any, ref: number) => void): number {
      if (!channel.getChannel()) {
        throw new Error('Cannot push event: not joined to a LiveView');
      }

      const ref = ++eventRef;

      if (onReply) {
        channel.pushEvent(event, payload, {
          onSuccess: (response: any) => onReply(response, ref),
          onError: (error: any) => onReply({ error }, ref),
          onTimeout: () => onReply({ error: 'timeout' }, ref),
        });
      } else {
        channel.pushEvent(event, payload);
      }

      return ref;
    },

    pushEventTo(target: string, event: string, payload: Record<string, any> = {}, onReply?: (reply: any, ref: number) => void): number {
      // Add phx_target to payload for LiveComponent targeting
      const targetedPayload = {
        ...payload,
        phx_target: target,
      };

      return client.pushEvent(event, targetedPayload, onReply);
    },

    handleEvent(event: string, callback: (payload: any) => void): () => void {
      // Always try to register immediately if channel exists
      if (channel.getChannel()) {
        const ref = channel.getChannel()!.on(event, callback);
        return () => {
          if (typeof ref === 'number') {
            channel.getChannel()?.off(event, ref);
          }
        };
      }

      // Store for later when channel is available
      if (!eventHandlers.has(event)) {
        eventHandlers.set(event, new Set());
      }
      eventHandlers.get(event)!.add(callback);

      return () => {
        eventHandlers.get(event)?.delete(callback);
      };
    },
  };

  return client;
}