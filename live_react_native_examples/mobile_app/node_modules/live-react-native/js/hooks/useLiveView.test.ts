import { useLiveView } from './useLiveView';

// Mock React hooks
jest.mock('react', () => {
  let clientRef = { current: null };

  return {
    useState: jest.fn((initial) => [initial, jest.fn()]),
    useRef: jest.fn((initial) => {
      if (initial === null) {
        // This is likely the clientRef
        return clientRef;
      }
      return { current: initial };
    }),
    useCallback: jest.fn((fn) => fn),
    useMemo: jest.fn((fn) => fn()),
    useEffect: jest.fn((effectFn) => {
      // Simulate the effect running immediately to set up the client
      effectFn();
    }),
  };
});

// Mock the entire LiveViewChannel module to provide createLiveViewClient
jest.mock('../client/LiveViewChannel', () => {
  const mockClient = {
    connect: jest.fn().mockResolvedValue(undefined),
    disconnect: jest.fn(),
    joinLiveView: jest.fn(),
    leaveLiveView: jest.fn(),
    pushEvent: jest.fn().mockReturnValue(1),
    pushEventTo: jest.fn().mockReturnValue(2),
    handleEvent: jest.fn().mockReturnValue(() => {}),
  };

  return {
    createLiveViewClient: jest.fn(() => mockClient),
    LiveViewChannel: jest.fn(),
  };
});

// **FUNCTIONAL API TESTS (Phase 2.1B-D) - ONLY ONES THAT WORK**
describe('useLiveView Hook - Refactored Functional API', () => {
  let createLiveViewClient: any;
  let mockClient: any;
  let clientRef: any;

  beforeEach(() => {
    jest.clearAllMocks();

    const LiveViewChannelModule = require('../client/LiveViewChannel');
    createLiveViewClient = LiveViewChannelModule.createLiveViewClient;

    // Get the mock client from the mocked module
    mockClient = createLiveViewClient();

    // Get access to the clientRef from the mocked React module
    const React = require('react');
    clientRef = { current: null };

    // Set up useRef to return our controlled clientRef for null initial values
    React.useRef.mockImplementation((initial: any) => {
      if (initial === null) {
        return clientRef;
      }
      return { current: initial };
    });

    // Set up useEffect to simulate the client being set up
    React.useEffect.mockImplementation((effectFn: any) => {
      effectFn();
      // After effect runs, set the client
      clientRef.current = mockClient;
    });
  });

  test('useLiveView uses createLiveViewClient instead of LiveViewChannel class', () => {
    // Call the hook
    useLiveView('/counter', { initial_count: 0 });

    // Should create client instead of using class constructor
    expect(createLiveViewClient).toHaveBeenCalledWith(expect.objectContaining({
      url: expect.any(String),
      params: expect.any(Object),
    }));

    // Should connect and join using functional API
    expect(mockClient.connect).toHaveBeenCalled();
  });

  test('useLiveView returns the functional API interface', () => {
    const result = useLiveView('/counter', { initial_count: 0 });

    // Should return the expected interface structure
    expect(result).toHaveProperty('loading');
    expect(result).toHaveProperty('assigns');
    expect(result).toHaveProperty('error');
    expect(result).toHaveProperty('pushEvent');
    expect(result).toHaveProperty('pushEventTo');
    expect(result).toHaveProperty('handleEvent');
    expect(result).toHaveProperty('memoizedProps');
    expect(result).toHaveProperty('computedValues');

    // Should be functions
    expect(typeof result.pushEvent).toBe('function');
    expect(typeof result.pushEventTo).toBe('function');
    expect(typeof result.handleEvent).toBe('function');
  });

  test('useLiveView pushEvent delegates to functional client', () => {
    const result = useLiveView('/counter', {});

    // Call pushEvent
    result.pushEvent('increment', { amount: 1 });

    // Should call the functional client's pushEvent
    // The third parameter is eventOptions.onReply which is undefined for empty eventOptions
    expect(mockClient.pushEvent).toHaveBeenCalledWith('increment', { amount: 1 }, undefined);
  });

  test('useLiveView cleanup disconnects functional client', () => {
    const result = useLiveView('/counter', {});

    // Call cleanup
    result.cleanup();

    // Should call disconnect and leave on the functional client
    expect(mockClient.leaveLiveView).toHaveBeenCalled();
    expect(mockClient.disconnect).toHaveBeenCalled();
  });
});